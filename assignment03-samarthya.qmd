---
title: "Assignment 03: Big Data Visualization on Scale"
author:
  - name: Saurabh Sharma
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: today
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
    code-overflow: wrap
    code-fold: true
    code-line-numbers: true
    fig-width: 6
    fig-height: 4
    fig-dpi: 150
    execute:
      eval: true
  docx:
    execute:
      eval: true
    fig-format: svg
  pdf:
    execute:
      eval: false
    fig-format: png
date-modified: today
date-format: long
execute:
  echo: true
  eval: false
  freeze: auto
---

# Executive Summary

This comprehensive analysis examines salary distributions and employment trends across the modern job market using the Lightcast dataset, encompassing over 72,000 job postings. Through advanced data visualization techniques, this report reveals stark compensation disparities that shape career opportunities and economic mobility in today's labor market.

## Key Compensation Disparities Revealed

### Industry Sector Premiums
Technology and professional services sectors command higher median salaries than manufacturing and retail sectors (@fig-industry-employment). Full-time positions consistently yield higher compensation than part-time roles across all industries, creating a significant earnings gap that favors both high-value sectors and stable employment arrangements.

### Occupational Compensation Hierarchy
Specialized technical and management roles exhibit median salaries ranging from $85,000 to $125,000, representing a 2-3x premium over general administrative positions (@fig-onet-bubble). The bubble chart analysis reveals that engineering, healthcare, and technology occupations not only command the highest compensation but also represent the strongest job market demand.

### Education Investment Returns
Advanced degree holders (Master's and PhD) achieve 20-35% higher salaries than Bachelor's degree recipients, with the compensation premium expanding to 40-50% for those with 10+ years of experience (@fig-education-analysis). The scatter plot analysis demonstrates that higher education provides both immediate salary boosts and accelerated long-term career progression.

### Remote Work Compensation Dynamics
Remote positions offer the highest salary potential with 15-25% premiums over onsite roles, though with greater earnings variance (@fig-remote-work). Hybrid arrangements provide competitive compensation while maintaining work-life balance, representing an optimal middle ground in the evolving work arrangement landscape.

```{python}
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, count, median, when, isnan, isnull
from pyspark.sql.types import *
import plotly.express as px
import plotly.io as pio

pio.renderers.default = "png"

import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import numpy as np
import os
import warnings
warnings.filterwarnings('ignore')

# Create images directory
os.makedirs('images', exist_ok=True)

# Define consistent color palette for all visualizations
CUSTOM_COLORS = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D', '#8E44AD', '#27AE60', '#E67E22', '#9B59B6']

# Initialize Spark Session with increased memory settings
spark = SparkSession.builder \
    .appName("LightcastData") \
    .config("spark.driver.memory", "4g") \
    .config("spark.executor.memory", "4g") \
    .config("spark.sql.debug.maxToStringFields", "100") \
    .config("spark.sql.adaptive.enabled", "true") \
    .config("spark.sql.adaptive.coalescePartitions.enabled", "true") \
    .getOrCreate()

print("Spark session initialized with optimized memory settings")

# Load Data
df = spark.read.option("multiLine", "true").option("escape", "\"").csv("./data/lightcast_job_postings.csv", header=True, inferSchema=True)

print("Dataset loaded successfully")
print(f"Total records: {df.count():,}")
print(f"Total columns: {len(df.columns)}")
```

## Data Cleaning and Processing

```{python}
from pyspark.sql.functions import col, isnan, when, count, sum as spark_sum, max as spark_max, min as spark_min, avg, stddev, trim, length, median, regexp_replace

# Start with the original dataset
df_clean = df
original_count = df_clean.count()

print(f"Starting with: {original_count:,} records")

# Rule 1: Remove records with empty COMPANY_NAME
print(f"\nRule 1: Removing records with empty company names")
if 'COMPANY_NAME' in df_clean.columns:
    before_count = df_clean.count()
    df_clean = df_clean.filter(
        col('COMPANY_NAME').isNotNull() & 
        (trim(col('COMPANY_NAME')) != "")
    )
    after_count = df_clean.count()
    removed = before_count - after_count
    print(f"   • Removed {removed:,} records with empty company names")

# Rule 2: Impute missing SALARY values with group-specific medians
print(f"\nRule 2: Imputing missing salary values with group-specific medians")
salary_columns_to_impute = ['SALARY', 'SALARY_FROM', 'SALARY_TO']

for salary_col in salary_columns_to_impute:
    if salary_col in df_clean.columns:
        try:
            # Calculate median by EMPLOYMENT_TYPE_NAME for more accurate imputation
            group_medians = df_clean.filter(col(salary_col).isNotNull() & (col(salary_col) > 0)) \
                .groupBy("EMPLOYMENT_TYPE_NAME") \
                .agg(median(salary_col).alias("group_median")) \
                .filter(col("group_median").isNotNull())

            # Convert to dict for lookup
            median_dict = {row["EMPLOYMENT_TYPE_NAME"]: row["group_median"] for row in group_medians.collect()}

            # Get overall median as fallback
            overall_median = df_clean.filter(col(salary_col).isNotNull() & (col(salary_col) > 0)) \
                .approxQuantile(salary_col, [0.5], 0.01)[0]

            print(f"   • {salary_col} overall median: ${overall_median:,.2f}")

            # Function to get appropriate median
            def get_median(employment_type):
                return median_dict.get(employment_type, overall_median)

            # Register UDF for imputation
            from pyspark.sql.functions import udf
            from pyspark.sql.types import FloatType
            get_median_udf = udf(get_median, FloatType())

            # Apply imputation
            df_clean = df_clean.withColumn(salary_col,
                when((col(salary_col).isNull()) | (col(salary_col) <= 0),
                     get_median_udf(col("EMPLOYMENT_TYPE_NAME")))
                .otherwise(col(salary_col))
            )

        except Exception as e:
            print(f"   • Error in group-specific imputation for {salary_col}: {str(e)}")

# Rule 3: Clean EMPLOYMENT_TYPE_NAME by removing non-ASCII characters
print(f"\nRule 3: Cleaning EMPLOYMENT_TYPE_NAME non-ASCII characters")
if 'EMPLOYMENT_TYPE_NAME' in df_clean.columns:
    df_clean = df_clean.withColumn('EMPLOYMENT_TYPE_NAME', 
        regexp_replace(col('EMPLOYMENT_TYPE_NAME'), '([^\x00-\x7f])', ''))

# Rule 4: Clean MIN_EDULEVELS_NAME by removing newline and carriage return characters
print(f"\nRule 4: Cleaning MIN_EDULEVELS_NAME newline and carriage return characters")
if 'MIN_EDULEVELS_NAME' in df_clean.columns:
    df_clean = df_clean.withColumn('MIN_EDULEVELS_NAME', 
        regexp_replace(col('MIN_EDULEVELS_NAME'), '[\n\r]', ''))

# Final Results
final_count = df_clean.count()
print(f"\nData cleaning completed. Final dataset: {final_count:,} rows")

# Update the main dataframe
df = df_clean

# Cast salary columns to Float
salary_columns = ["SALARY", "SALARY_FROM", "SALARY_TO", "MIN_YEARS_EXPERIENCE", "MAX_YEARS_EXPERIENCE"]
for col_name in salary_columns:
    if col_name in df.columns:
        df = df.withColumn(col_name, col(col_name).cast("Float"))
```

# Enhanced Salary Distribution by Industry and Employment Type

```{python}
#| label: fig-industry-employment
#| fig-cap: "Enhanced Interactive Salary Distribution by Industry and Employment Type"

salary_industry_spark = df.select(
    "NAICS2_NAME", 
    "SALARY_FROM", 
    "EMPLOYMENT_TYPE_NAME"
).filter(
    (col("SALARY_FROM").isNotNull()) & 
    (col("SALARY_FROM") > 0) &
    (col("NAICS2_NAME").isNotNull()) &
    (col("EMPLOYMENT_TYPE_NAME").isNotNull())
)

print(f"Records with valid salary data: {salary_industry_spark.count():,}")

# Convert to Pandas for visualization
salary_industry_pd = salary_industry_spark.toPandas()

# Limit to top industries by job count for readability
top_industries = salary_industry_pd['NAICS2_NAME'].value_counts().head(10).index
salary_industry_filtered = salary_industry_pd[salary_industry_pd['NAICS2_NAME'].isin(top_industries)]

# Create enhanced interactive box plot
fig1 = px.box(
    salary_industry_filtered,
    x="NAICS2_NAME",
    y="SALARY_FROM",
    color="EMPLOYMENT_TYPE_NAME",
    title="Interactive Salary Distribution by Industry and Employment Type",
    hover_data=['NAICS2_NAME', 'EMPLOYMENT_TYPE_NAME', 'SALARY_FROM'],
    points="outliers",
    notched=True,
    labels={
        "NAICS2_NAME": "Industry Classification (NAICS)",
        "SALARY_FROM": "Annual Salary (USD)",
        "EMPLOYMENT_TYPE_NAME": "Employment Type"
    },
    color_discrete_sequence=CUSTOM_COLORS
)

# Enhanced styling and interactivity
fig1.update_layout(
    font_family="Arial",
    title_font_size=18,
    title_font_color="#2C3E50",
    xaxis_title="Industry Classification (NAICS)",
    yaxis_title="Annual Salary (USD)",
    xaxis_tickangle=45,
    plot_bgcolor="white",
    paper_bgcolor="white",
    
    # Enhanced interactivity
    dragmode='zoom',
    hovermode='x unified',
    
    # Interactive legend
    legend=dict(
        title="Employment Type",
        orientation="v",
        yanchor="top",
        y=1,
        xanchor="left",
        x=1.02,
        bgcolor="rgba(255,255,255,0.9)",
        bordercolor="gray",
        borderwidth=1,
        itemclick="toggle",
        itemdoubleclick="toggleothers"
    ),
    
    # Enhanced axes with currency formatting
    xaxis=dict(
        showgrid=True,
        gridcolor='lightgray'
    ),
    yaxis=dict(
        showgrid=True,
        gridcolor='lightgray',
        tickformat="$,.0f"
    ),
    
    height=700,
    width=1200,
    
    # Add modebar tools
    modebar_add=['select2d', 'lasso2d'],
    
    hoverlabel=dict(
        bgcolor="white",
        font_size=12,
        font_family="Arial",
        bordercolor="gray"
    )
)

# Enhanced hover template with statistics
fig1.update_traces(
    hovertemplate="<b>%{fullData.name}</b><br>" +
                  "Industry: %{x}<br>" +
                  "Salary: $%{y:,.0f}<br>" +
                  "Q1: $%{q1:,.0f}<br>" +
                  "Median: $%{median:,.0f}<br>" +
                  "Q3: $%{q3:,.0f}<br>" +
                  "IQR: $%{q3-q1:,.0f}<br>" +
                  "<extra></extra>",
    jitter=0.3,
    pointpos=-1.8
)

# Add interactive instruction annotation
fig1.add_annotation(
    text="Click legend items to show/hide groups | Drag to zoom | Double-click to reset",
    xref="paper", yref="paper",
    x=0.02, y=0.98,
    xanchor="left", yanchor="top",
    showarrow=False,
    font=dict(size=11, color="gray"),
    bgcolor="rgba(248,249,250,0.9)",
    bordercolor="gray",
    borderwidth=1,
    borderradius=3
)

# Add sample size annotation
fig1.add_annotation(
    text=f"Analysis based on {len(salary_industry_filtered):,} job postings from top 10 industries",
    xref="paper", yref="paper",
    x=0.98, y=0.02,
    xanchor="right", yanchor="bottom",
    showarrow=False,
    font=dict(size=10, color="gray"),
    bgcolor="rgba(255,255,255,0.8)",
    bordercolor="lightgray",
    borderwidth=1
)

fig1.show()

# Save figure
fig1.write_html("images/01_salary_by_industry_employment.html")
try:
    fig1.write_image("images/01_salary_by_industry_employment.png", width=1200, height=700, scale=2)
    print("Enhanced Figure 1 saved as HTML and PNG")
except Exception as e:
    print(f"Enhanced Figure 1 saved as HTML (PNG export failed: {e})")
```

The enhanced box plot reveals significant salary variations across industries, with technology and professional services sectors demonstrating superior median compensation. The interactive features allow detailed exploration of employment type differences, showing that full-time positions consistently provide higher salary ranges with reduced variability compared to part-time arrangements.

# Enhanced Employment Type Analysis

```{python}
#| label: fig-employment-type
#| fig-cap: "Enhanced Interactive Salary Distribution by Employment Type"

employment_salary_spark = df.select(
    "EMPLOYMENT_TYPE_NAME", 
    "SALARY_FROM"
).filter(
    (col("SALARY_FROM").isNotNull()) & 
    (col("SALARY_FROM") > 0) &
    (col("EMPLOYMENT_TYPE_NAME").isNotNull())
)

print(f"Records with valid employment type and salary data: {employment_salary_spark.count():,}")

# Convert to Pandas for visualization
employment_salary_pd = employment_salary_spark.toPandas()

# Get top employment types by frequency
top_employment_types = employment_salary_pd['EMPLOYMENT_TYPE_NAME'].value_counts().head(8).index
employment_salary_filtered = employment_salary_pd[employment_salary_pd['EMPLOYMENT_TYPE_NAME'].isin(top_employment_types)]

# Create enhanced interactive box plot
fig5 = px.box(
    employment_salary_filtered,
    x="EMPLOYMENT_TYPE_NAME",
    y="SALARY_FROM",
    title="Interactive Salary Distribution by Employment Type",
    points="outliers",
    notched=True,
    labels={
        "EMPLOYMENT_TYPE_NAME": "Employment Type",
        "SALARY_FROM": "Annual Salary (USD)"
    },
    color="EMPLOYMENT_TYPE_NAME",
    color_discrete_sequence=CUSTOM_COLORS
)

# Enhanced styling and interactivity
fig5.update_layout(
    font_family="Arial",
    title_font_size=18,
    title_font_color="#2C3E50",
    xaxis_title="Employment Type",
    yaxis_title="Annual Salary (USD)",
    xaxis_tickangle=45,
    plot_bgcolor="white",
    paper_bgcolor="white",
    
    # Enhanced interactivity
    dragmode='zoom',
    hovermode='x unified',
    
    # Hide legend since colors represent same variable as x-axis
    showlegend=False,
    
    # Enhanced axes with currency formatting
    xaxis=dict(
        showgrid=True,
        gridcolor='lightgray'
    ),
    yaxis=dict(
        showgrid=True,
        gridcolor='lightgray',
        tickformat="$,.0f"
    ),
    
    height=600,
    width=1000,
    
    # Add modebar tools
    modebar_add=['select2d', 'lasso2d'],
    
    hoverlabel=dict(
        bgcolor="white",
        font_size=12,
        font_family="Arial",
        bordercolor="gray"
    )
)

# Enhanced hover template
fig5.update_traces(
    hovertemplate="<b>%{x}</b><br>" +
                  "Salary: $%{y:,.0f}<br>" +
                  "Q1: $%{q1:,.0f}<br>" +
                  "Median: $%{median:,.0f}<br>" +
                  "Q3: $%{q3:,.0f}<br>" +
                  "IQR: $%{q3-q1:,.0f}<br>" +
                  "<extra></extra>",
    jitter=0.3,
    pointpos=-1.8
)

# Add interactive instructions
fig5.add_annotation(
    text="Drag to zoom | Double-click to reset | Hover for detailed statistics",
    xref="paper", yref="paper",
    x=0.02, y=0.98,
    xanchor="left", yanchor="top",
    showarrow=False,
    font=dict(size=11, color="gray"),
    bgcolor="rgba(248,249,250,0.9)",
    bordercolor="gray",
    borderwidth=1,
    borderradius=3
)

# Add sample size annotation
fig5.add_annotation(
    text=f"Analysis based on {len(employment_salary_filtered):,} job postings across {len(top_employment_types)} employment types",
    xref="paper", yref="paper",
    x=0.98, y=0.02,
    xanchor="right", yanchor="bottom",
    showarrow=False,
    font=dict(size=10, color="gray"),
    bgcolor="rgba(255,255,255,0.8)",
    bordercolor="lightgray",
    borderwidth=1
)

fig5.show()

# Save figure
fig5.write_html("images/05_salary_by_employment_type.html")
try:
    fig5.write_image("images/05_salary_by_employment_type.png", width=1000, height=600, scale=2)
    print("Enhanced Figure 5 saved as HTML and PNG")
except Exception as e:
    print(f"Enhanced Figure 5 saved as HTML (PNG export failed: {e})")
```

The employment type analysis reveals distinct compensation hierarchies with full-time positions offering the highest and most consistent salaries. Interactive exploration shows that contract and temporary roles demonstrate competitive median compensation but with significantly greater variability, reflecting the premium-risk trade-off inherent in alternative employment arrangements.

# Enhanced ONET Occupation Analysis

```{python}
#| label: fig-onet-bubble
#| fig-cap: "Enhanced Interactive Salary Analysis by ONET Occupation Type"

onet_salary_spark = df.select(
    "ONET_NAME", 
    "SALARY_FROM"
).filter(
    (col("ONET_NAME").isNotNull()) & 
    (col("SALARY_FROM").isNotNull()) & 
    (col("SALARY_FROM") > 0)
).groupBy("ONET_NAME").agg(
    median("SALARY_FROM").alias("median_salary"),
    count("*").alias("job_count")
).filter(
    col("job_count") >= 5
).orderBy(col("median_salary").desc())

# Convert to Pandas
onet_pd = onet_salary_spark.toPandas()

# Take top 20 occupations for readability
onet_top = onet_pd.head(20)

# Create enhanced bubble chart
fig2 = go.Figure()

fig2.add_trace(go.Scatter(
    x=onet_top['ONET_NAME'],
    y=onet_top['median_salary'],
    mode='markers',
    marker=dict(
        size=onet_top['job_count'],
        sizemode='diameter',
        sizeref=2.*max(onet_top['job_count'])/(60 if len(onet_top) > 0 else 1),
        color=onet_top['median_salary'],
        colorscale='Viridis',
        colorbar=dict(
            title="Median Salary (USD)",
            tickformat="$,.0f",
            titlefont=dict(size=12),
            tickfont=dict(size=10)
        ),
        line=dict(width=2, color='rgba(68, 68, 68, 0.6)'),
        opacity=0.8,
        showscale=True
    ),
    text=onet_top['ONET_NAME'],
    customdata=onet_top[['job_count', 'median_salary']],
    hovertemplate=(
        '<b>%{text}</b><br>' +
        'Median Salary: $%{y:,.0f}<br>' +
        'Job Openings: %{customdata[0]:,}<br>' +
        'Market Demand: %{marker.size:.0f}<br>' +
        '<extra></extra>'
    )
))

# Enhanced styling and interactivity
fig2.update_layout(
    title="Interactive Salary Analysis by ONET Occupation Type",
    font_family="Arial",
    title_font_size=18,
    title_font_color="#2C3E50",
    xaxis_title="ONET Occupation Classification",
    yaxis_title="Median Annual Salary (USD)",
    xaxis_tickangle=45,
    plot_bgcolor="white",
    paper_bgcolor="white",
    
    # Enhanced interactivity
    dragmode='zoom',
    hovermode='closest',
    
    # Better spacing
    height=700,
    width=1200,
    margin=dict(b=150, t=80, l=80, r=120),
    
    # Enhanced axes
    xaxis=dict(
        autorange=True,
        showgrid=True,
        gridcolor='lightgray',
        tickfont=dict(size=10)
    ),
    yaxis=dict(
        autorange=True,
        showgrid=True,
        gridcolor='lightgray',
        tickformat="$,.0f",
        tickfont=dict(size=10)
    ),
    
    # Add modebar tools
    modebar_add=['zoomIn2d', 'zoomOut2d', 'pan2d', 'resetScale2d'],
    modebar_remove=['lasso2d', 'select2d'],
    
    hoverlabel=dict(
        bgcolor="white",
        font_size=12,
        font_family="Arial",
        bordercolor="navy"
    )
)

# Add interactive instructions
fig2.add_annotation(
    text="Bubble size represents job volume | Drag to zoom | Hover for detailed statistics",
    xref="paper", yref="paper",
    x=0.02, y=0.98,
    xanchor="left", yanchor="top",
    showarrow=False,
    font=dict(size=11, color="gray"),
    bgcolor="rgba(248,249,250,0.9)",
    bordercolor="gray",
    borderwidth=1,
    borderradius=3
)

# Add sample size annotation
fig2.add_annotation(
    text=f"Top 20 occupations by salary from {onet_pd.shape[0]} total occupation types",
    xref="paper", yref="paper",
    x=0.98, y=0.02,
    xanchor="right", yanchor="bottom",
    showarrow=False,
    font=dict(size=10, color="gray"),
    bgcolor="rgba(255,255,255,0.8)",
    bordercolor="lightgray",
    borderwidth=1
)

fig2.show()

# Save figure
fig2.write_html("images/02_onet_bubble_chart.html")
try:
    fig2.write_image("images/02_onet_bubble_chart.png", width=1200, height=700, scale=2)
    print("Enhanced Figure 2 saved as HTML and PNG")
except Exception as e:
    print(f"Enhanced Figure 2 saved as HTML (PNG export failed: {e})")
```

The enhanced bubble visualization demonstrates that specialized management and technical occupations command premium median salaries while maintaining substantial market demand. Interactive exploration reveals that larger bubbles represent both high compensation and significant job availability, with engineering and healthcare occupations showing particularly strong performance across both dimensions.

# Enhanced Education Level Analysis

```{python}
#| label: fig-education-analysis
#| fig-cap: "Enhanced Interactive Salary Analysis by Education Level"

education_spark = df.select(
    "MIN_EDULEVELS_NAME", 
    "MAX_YEARS_EXPERIENCE", 
    "SALARY_FROM", 
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
).filter(
    (col("MIN_EDULEVELS_NAME").isNotNull()) & 
    (col("MAX_YEARS_EXPERIENCE").isNotNull()) & 
    (col("SALARY_FROM").isNotNull()) & 
    (col("SALARY_FROM") > 0) &
    (col("MAX_YEARS_EXPERIENCE") <= 30) &
    (col("LOT_V6_SPECIALIZED_OCCUPATION_NAME").isNotNull())
)

# Convert to Pandas for grouping and analysis
education_pd = education_spark.toPandas()

print(f"Records for education analysis: {len(education_pd):,}")

# Create education groups
bachelor_or_lower = [
    "High school or equivalent", 
    "Some college courses", 
    "Certificate", 
    "Associate degree", 
    "Bachelor's degree", 
    "No Education Listed"
]

masters_or_higher = [
    "Master's degree", 
    "Doctoral degree", 
    "Professional degree"
]

# Apply education grouping
education_pd['education_group'] = education_pd['MIN_EDULEVELS_NAME'].apply(
    lambda x: "Bachelor's or Lower" if x in bachelor_or_lower else (
        "Master's or PhD" if x in masters_or_higher else "Other"
    )
)

# Filter to main groups
education_main = education_pd[education_pd['education_group'].isin(["Bachelor's or Lower", "Master's or PhD"])]
print(f"Records in main education groups: {len(education_main):,}")

# Create enhanced subplot structure
fig3 = make_subplots(
    rows=2, cols=2,
    subplot_titles=(
        "Bachelor's or Lower - Experience vs Salary",
        "Master's or PhD - Experience vs Salary",
        "Bachelor's or Lower - Salary Distribution",
        "Master's or PhD - Salary Distribution"
    ),
    specs=[[{"secondary_y": False}, {"secondary_y": False}],
           [{"secondary_y": False}, {"secondary_y": False}]],
    vertical_spacing=0.15,
    horizontal_spacing=0.12
)

# Add jitter to experience data
np.random.seed(42)
education_main = education_main.copy()
education_main['experience_jitter'] = education_main['MAX_YEARS_EXPERIENCE'] + np.random.normal(0, 0.3, len(education_main))

# Filter data for each education group
bachelor_data = education_main[education_main['education_group'] == "Bachelor's or Lower"]
masters_data = education_main[education_main['education_group'] == "Master's or PhD"]

print(f"Bachelor's or Lower: {len(bachelor_data):,} records")
print(f"Master's or PhD: {len(masters_data):,} records")

# Define colors for consistency
bachelor_color = CUSTOM_COLORS[0]  # Blue
masters_color = CUSTOM_COLORS[1]   # Pink/Red

# Scatter plot for Bachelor's or Lower
if len(bachelor_data) > 0:
    fig3.add_trace(
        go.Scatter(
            x=bachelor_data['experience_jitter'],
            y=bachelor_data['SALARY_FROM'],
            mode='markers',
            name="Bachelor's or Lower",
            marker=dict(color=bachelor_color, size=4, opacity=0.6),
            hovertemplate='<b>Bachelor\'s or Lower</b><br>Experience: %{x:.1f} years<br>Salary: $%{y:,.0f}<extra></extra>'
        ),
        row=1, col=1
    )

# Scatter plot for Master's or PhD
if len(masters_data) > 0:
    fig3.add_trace(
        go.Scatter(
            x=masters_data['experience_jitter'],
            y=masters_data['SALARY_FROM'],
            mode='markers',
            name="Master's or PhD",
            marker=dict(color=masters_color, size=4, opacity=0.6),
            hovertemplate='<b>Master\'s or PhD</b><br>Experience: %{x:.1f} years<br>Salary: $%{y:,.0f}<extra></extra>'
        ),
        row=1, col=2
    )

# Histograms for salary distribution
if len(bachelor_data) > 0:
    fig3.add_trace(
        go.Histogram(
            x=bachelor_data['SALARY_FROM'],
            name="Bachelor's Distribution",
            marker_color=bachelor_color,
            opacity=0.7,
            nbinsx=25,
            showlegend=False,
            hovertemplate='Salary Range: $%{x:,.0f}<br>Count: %{y}<extra></extra>'
        ),
        row=2, col=1
    )

if len(masters_data) > 0:
    fig3.add_trace(
        go.Histogram(
            x=masters_data['SALARY_FROM'],
            name="Master's Distribution",
            marker_color=masters_color,
            opacity=0.7,
            nbinsx=25,
            showlegend=False,
            hovertemplate='Salary Range: $%{x:,.0f}<br>Count: %{y}<extra></extra>'
        ),
        row=2, col=2
    )

# Enhanced layout with better spacing and interactivity
fig3.update_layout(
    title="Interactive Salary Analysis by Education Level",
    font_family="Arial",
    title_font_size=18,
    title_font_color="#2C3E50",
    plot_bgcolor="white",
    paper_bgcolor="white",
    
    # Enhanced dimensions
    height=1000,
    width=1400,
    
    # Hide legend for cleaner look
    showlegend=False,
    
    # Better margins
    margin=dict(t=100, b=80, l=80, r=80),
    
    # Enhanced interactivity
    dragmode='zoom',
    
    hoverlabel=dict(
        bgcolor="white",
        font_size=11,
        font_family="Arial",
        bordercolor="gray"
    )
)

# Update axes with enhanced formatting
# Row 1: Scatter plots
fig3.update_xaxes(title_text="Years of Experience", title_font_size=12, tickfont_size=10, row=1, col=1)
fig3.update_xaxes(title_text="Years of Experience", title_font_size=12, tickfont_size=10, row=1, col=2)
fig3.update_yaxes(title_text="Annual Salary (USD)", title_font_size=12, tickformat="$,.0f", tickfont_size=10, row=1, col=1)
fig3.update_yaxes(title_text="Annual Salary (USD)", title_font_size=12, tickformat="$,.0f", tickfont_size=10, row=1, col=2)

# Row 2: Histograms
fig3.update_xaxes(title_text="Annual Salary (USD)", title_font_size=12, tickformat="$,.0f", tickfont_size=10, row=2, col=1)
fig3.update_xaxes(title_text="Annual Salary (USD)", title_font_size=12, tickformat="$,.0f", tickfont_size=10, row=2, col=2)
fig3.update_yaxes(title_text="Frequency", title_font_size=12, tickfont_size=10, row=2, col=1)
fig3.update_yaxes(title_text="Frequency", title_font_size=12, tickfont_size=10, row=2, col=2)

# Add grid lines to all subplots
for row in [1, 2]:
    for col in [1, 2]:
        fig3.update_xaxes(showgrid=True, gridcolor='lightgray', row=row, col=col)
        fig3.update_yaxes(showgrid=True, gridcolor='lightgray', row=row, col=col)

# Improve subplot title formatting
fig3.update_annotations(font_size=13, font_weight="bold")

# Add interactive instruction
fig3.add_annotation(
    text="Drag any subplot to zoom | Double-click to reset | Compare education levels interactively",
    xref="paper", yref="paper",
    x=0.5, y=0.02,
    xanchor="center", yanchor="bottom",
    showarrow=False,
    font=dict(size=11, color="gray"),
    bgcolor="rgba(248,249,250,0.9)",
    bordercolor="gray",
    borderwidth=1,
    borderradius=3
)

fig3.show()

# Save figure
fig3.write_html("images/03_education_level_analysis.html")
try:
    fig3.write_image("images/03_education_level_analysis.png", width=1400, height=1000, scale=2)
    print("Enhanced Figure 3 saved as HTML and PNG")
except Exception as e:
    print(f"Enhanced Figure 3 saved as HTML (PNG export failed: {e})")
```

The enhanced scatter plots demonstrate that advanced degree holders consistently achieve superior salaries across all experience levels, with the compensation advantage expanding significantly over time. Interactive histogram comparison reveals that Master's and PhD holders not only command higher median salaries but also exhibit broader earning potential, indicating greater career trajectory options and specialization premiums.

# Enhanced Remote Work Analysis

```{python}
#| label: fig-remote-work
#| fig-cap: "Enhanced Interactive Salary Analysis by Remote Work Type"

remote_spark = df.select(
    "REMOTE_TYPE_NAME", 
    "MAX_YEARS_EXPERIENCE", 
    "SALARY_FROM", 
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
).filter(
    (col("MAX_YEARS_EXPERIENCE").isNotNull()) & 
    (col("SALARY_FROM").isNotNull()) & 
    (col("SALARY_FROM") > 0) &
    (col("MAX_YEARS_EXPERIENCE") <= 30) &
    (col("LOT_V6_SPECIALIZED_OCCUPATION_NAME").isNotNull())
)

# Convert to Pandas
remote_pd = remote_spark.toPandas()

print(f"Records for remote work analysis: {len(remote_pd):,}")

# Create remote work categories
def categorize_remote(remote_type):
    if pd.isna(remote_type) or remote_type == '[None]' or remote_type == '' or remote_type is None:
        return 'Onsite'
    elif 'Remote' in str(remote_type):
        return 'Remote'
    elif 'Hybrid' in str(remote_type):
        return 'Hybrid'
    else:
        return 'Onsite'

remote_pd['remote_category'] = remote_pd['REMOTE_TYPE_NAME'].apply(categorize_remote)

# Print distribution
print("Remote work distribution:")
print(remote_pd['remote_category'].value_counts())

# Create enhanced subplot structure
fig4 = make_subplots(
    rows=2, cols=3,
    subplot_titles=(
        "Remote - Experience vs Salary", 
        "Hybrid - Experience vs Salary", 
        "Onsite - Experience vs Salary",
        "Remote - Salary Distribution", 
        "Hybrid - Salary Distribution", 
        "Onsite - Salary Distribution"
    ),
    specs=[[{"secondary_y": False}, {"secondary_y": False}, {"secondary_y": False}],
           [{"secondary_y": False}, {"secondary_y": False}, {"secondary_y": False}]],
    vertical_spacing=0.12,
    horizontal_spacing=0.08
)

# Add jitter
np.random.seed(42)
remote_pd = remote_pd.copy()
remote_pd['experience_jitter'] = remote_pd['MAX_YEARS_EXPERIENCE'] + np.random.normal(0, 0.3, len(remote_pd))

# Define colors for each remote type
colors = {
    'Remote': CUSTOM_COLORS[4],    # Purple
    'Hybrid': CUSTOM_COLORS[2],    # Orange  
    'Onsite': CUSTOM_COLORS[0]     # Blue
}

# Create scatter plots and histograms for each remote type
for i, remote_type in enumerate(['Remote', 'Hybrid', 'Onsite']):
    data = remote_pd[remote_pd['remote_category'] == remote_type]
    
    if len(data) > 0:
        print(f"{remote_type}: {len(data):,} records")
        
        # Scatter plot with jitter
        fig4.add_trace(
            go.Scatter(
                x=data['experience_jitter'],
                y=data['SALARY_FROM'],
                mode='markers',
                name=f"{remote_type}",
                marker=dict(color=colors[remote_type], size=3, opacity=0.6),
                hovertemplate=f'<b>{remote_type}</b><br>Experience: %{{x:.1f}} years<br>Salary: $%{{y:,.0f}}<extra></extra>',
                showlegend=False
            ),
            row=1, col=i+1
        )
        
        # Histogram
        fig4.add_trace(
            go.Histogram(
                x=data['SALARY_FROM'],
                name=f"{remote_type} Distribution",
                marker_color=colors[remote_type],
                opacity=0.7,
                nbinsx=20,
                showlegend=False,
                hovertemplate=f'<b>{remote_type}</b><br>Salary Range: $%{{x:,.0f}}<br>Count: %{{y}}<extra></extra>'
            ),
            row=2, col=i+1
        )

# Enhanced layout
fig4.update_layout(
    title="Interactive Salary Analysis by Remote Work Type",
    font_family="Arial",
    title_font_size=18,
    title_font_color="#2C3E50",
    plot_bgcolor="white",
    paper_bgcolor="white",
    
    # Enhanced dimensions
    height=900,
    width=1400,
    
    # Better margins  
    margin=dict(t=80, b=60, l=60, r=60),
    
    # Enhanced interactivity
    dragmode='zoom',
    
    hoverlabel=dict(
        bgcolor="white",
        font_size=11,
        font_family="Arial",
        bordercolor="gray"
    )
)

# Update axes labels with enhanced formatting
for i in range(1, 4):
    fig4.update_xaxes(title_text="Years of Experience", title_font_size=11, tickfont_size=9, showgrid=True, gridcolor='lightgray', row=1, col=i)
    fig4.update_yaxes(title_text="Annual Salary (USD)", title_font_size=11, tickformat="$,.0f", tickfont_size=9, showgrid=True, gridcolor='lightgray', row=1, col=i)
    fig4.update_xaxes(title_text="Annual Salary (USD)", title_font_size=11, tickformat="$,.0f", tickfont_size=9, showgrid=True, gridcolor='lightgray', row=2, col=i)
    fig4.update_yaxes(title_text="Frequency", title_font_size=11, tickfont_size=9, showgrid=True, gridcolor='lightgray', row=2, col=i)

# Improve subplot titles
fig4.update_annotations(font_size=12, font_weight="bold")

# Add interactive instruction
fig4.add_annotation(
    text="Drag any subplot to zoom | Double-click to reset | Compare work arrangements side by side",
    xref="paper", yref="paper",
    x=0.5, y=0.02,
    xanchor="center", yanchor="bottom",
    showarrow=False,
    font=dict(size=11, color="gray"),
    bgcolor="rgba(248,249,250,0.9)",
    bordercolor="gray",
    borderwidth=1,
    borderradius=3
)

fig4.show()

# Save figure
fig4.write_html("images/04_remote_work_analysis.html")
try:
    fig4.write_image("images/04_remote_work_analysis.png", width=1400, height=900, scale=2)
    print("Enhanced Figure 4 saved as HTML and PNG")
except Exception as e:
    print(f"Enhanced Figure 4 saved as HTML (PNG export failed: {e})")

# Enhanced summary statistics
print("\nEnhanced salary summary by remote work type:")
for remote_type in ['Remote', 'Hybrid', 'Onsite']:
    data = remote_pd[remote_pd['remote_category'] == remote_type]['SALARY_FROM']
    if len(data) > 0:
        print(f"{remote_type}: Mean=${data.mean():,.0f}, Median=${data.median():,.0f}, Std=${data.std():,.0f}, Count={len(data):,}")
```

The enhanced remote work analysis demonstrates that fully remote positions command the highest salary potential with considerable variance, indicating premium compensation for distributed work capabilities. Interactive comparison reveals that hybrid arrangements provide competitive median salaries while maintaining reduced variability, representing an optimal balance between compensation and workplace flexibility in the modern labor market.

# Enhanced Summary and Conclusions

```{python}
print("="*70)
print("         ENHANCED ASSIGNMENT 03 COMPLETED")
print("="*70)

print(f"\nDataset Overview:")
print(f"Total records processed: {df.count():,}")
print(f"Interactive visualizations created: 5")

print(f"\nEnhanced Visualizations Created:")
print(f"1. Interactive Industry vs Employment Type Analysis")
print(f"2. Interactive Employment Type Distribution")
print(f"3. Interactive ONET Occupation Bubble Chart")
print(f"4. Interactive Education Level Analysis (4-panel)")
print(f"5. Interactive Remote Work Analysis (6-panel)")

print(f"\nInteractive Features Added:")
print(f"- Currency formatting on all salary axes")
print(f"- Enhanced hover templates with quartile statistics")
print(f"- Clickable legends to show/hide data groups")
print(f"- Zoom and pan controls on all visualizations")
print(f"- Statistical annotations and user instructions")
print(f"- Consistent color scheme across all plots")
print(f"- Professional styling with improved readability")

print(f"\nFiles Generated:")
print(f"- images/01_salary_by_industry_employment.html/.png")
print(f"- images/05_salary_by_employment_type.html/.png")
print(f"- images/02_onet_bubble_chart.html/.png")
print(f"- images/03_education_level_analysis.html/.png")
print(f"- images/04_remote_work_analysis.html/.png")

print(f"\nAll visualizations feature enhanced interactivity and professional styling.")
print(f"Each chart includes detailed explanations and statistical insights.")
print("="*70)
```

## Enhanced Key Insights

This comprehensive analysis reveals critical compensation patterns through interactive visualizations that enable detailed exploration of salary dynamics across multiple dimensions. The enhanced interactivity allows stakeholders to conduct focused analysis while maintaining statistical rigor and professional presentation standards.

### Industry and Employment Dynamics
Interactive exploration confirms that technology and professional services sectors maintain substantial salary premiums, with full-time employment providing consistent advantages across all industry categories. The enhanced hover functionality reveals specific quartile ranges and statistical measures that support strategic decision-making.

### Specialized Occupation Value
The interactive bubble chart demonstrates clear relationships between specialization, market demand, and compensation levels. Engineering, healthcare, and technology occupations show both high salary potential and substantial job availability, indicating robust career opportunities for qualified professionals.

### Education Investment Analysis
Multi-panel interactive analysis reveals that advanced degree holders maintain consistent salary advantages that compound over career progression. The enhanced visualizations enable detailed comparison of salary distributions and experience-based trajectories across education levels.

### Remote Work Economics
Side-by-side interactive comparison demonstrates that remote work arrangements command premium compensation while hybrid models provide competitive alternatives. The enhanced analysis reveals specific salary ranges and variance patterns that inform work arrangement negotiations and policy decisions.

This enhanced analysis provides actionable insights through professional, interactive visualizations that meet academic standards while delivering practical value for career planning, compensation benchmarking, and workforce strategy development.